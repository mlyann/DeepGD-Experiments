# -*- coding: utf-8 -*-
"""deepgd_demo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TP8YOcvU6m-iBF7coFTlO7ypqhXul-X-
"""

# Commented out IPython magic to ensure Python compatibility.
# %load_ext autoreload
# %autoreload 2

import random

import numpy as np
import torch
import torch_geometric as pyg
from tqdm.auto import *



import deepgd as dgd

device = "cpu"
for backend, device_name in {
    torch.backends.mps: "mps",
    torch.cuda: "cuda",
}.items():
    if backend.is_available():
        device = device_name

batch_size = 128
lr = 0.01

dataset = dgd.RomeDataset()
model = dgd.DeepGD().to(device)
criteria = {
    dgd.Stress(): 1,
    # dgd.EdgeVar(): 0,
    # dgd.Occlusion(): 0,
    # dgd.IncidentAngle(): 0,
    # dgd.TSNEScore(): 0,
}
optim = torch.optim.AdamW(model.parameters(), lr=lr)

datalist = list(dataset)
random.seed(12345)
random.shuffle(datalist)

train_loader = pyg.loader.DataLoader(datalist[:10000], batch_size=batch_size, shuffle=True)
val_loader = pyg.loader.DataLoader(datalist[11000:], batch_size=batch_size, shuffle=False)
test_loader = pyg.loader.DataLoader(datalist[10000:11000], batch_size=batch_size, shuffle=False)

for epoch in range(400):
    model.train()
    losses = []
    for batch in tqdm(train_loader):
        batch = batch.to(device)
        model.zero_grad()
        loss = 0
        for c, w in criteria.items():
            loss += w * c(model(batch), batch)
        loss.backward()
        optim.step()
        losses.append(loss.item())
    print(f'[Epoch {epoch}] Train Loss: {np.mean(losses)}')
    with torch.no_grad():
        model.eval()
        losses = []
        for batch in tqdm(val_loader, disable=True):
            batch = batch.to(device)
            loss = 0
            for c, w in criteria.items():
                loss += w * c(model(batch), batch)
            losses.append(loss.item())
        print(f'[Epoch {epoch}] Val Loss: {np.mean(losses)}')
# save the model
PATH = 'save_model_path'
torch.save(model.state_dict(), PATH)


from tqdm import tqdm
import networkx as nx
import matplotlib.pyplot as plt
from torch_geometric.utils import to_networkx

def visualize_graph(G, rei, pos=None):
    g2 = nx.Graph()
    for n in G.nodes():
      g2.add_node(n)
    #print(rei.shape)
    edge_list = []
    for i in range(rei.shape[1]):
      edge_list.append((rei[0][i], rei[1][i]))
    #print(edge_list)
    for u in G.nodes():
      for v in G.nodes():
        if u<v:
          if (u,v) in edge_list:
            g2.add_edge(u,v)
    if pos==None:
      nx.draw_networkx(g2, pos=nx.spring_layout(g2, seed=42), with_labels=False, cmap="Set2")
      #print("spring positions:", nx.spring_layout(G, seed=42))
    else:
      nx.draw_networkx(g2, pos=pos, with_labels=False, cmap="Set2")
    plt.show()
    return g2

